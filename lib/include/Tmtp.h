// **********************************************************************
// This file was generated by a TAF parser!
// TAF version 4.7.1 by WSRD Tencent.
// Generated from `Tmtp.jce'
// **********************************************************************

#ifndef __TMTP_H_
#define __TMTP_H_

#include <map>
#include <string>
#include <vector>
#include "jce/Jce.h"
using namespace std;
#include "tmtp_type.h"


namespace Toon
{
    struct Header : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "Toon.Header";
        }
        static string MD5()
        {
            return "a3d4c0d0ce50515cbd3d704ab4b7fba0";
        }
        Header()
        :pkgId(""),from(""),to(""),senderPK(""),receiverPK(""),compress(0),dup(0)
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(pkgId, 0);
            _os.write(from, 1);
            _os.write(to, 2);
            _os.write(senderPK, 3);
            _os.write(receiverPK, 4);
            _os.write(compress, 5);
            _os.write(dup, 6);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(pkgId, 0, false);
            _is.read(from, 1, false);
            _is.read(to, 2, false);
            _is.read(senderPK, 3, false);
            _is.read(receiverPK, 4, false);
            _is.read(compress, 5, false);
            _is.read(dup, 6, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(pkgId,"pkgId");
            _ds.display(from,"from");
            _ds.display(to,"to");
            _ds.display(senderPK,"senderPK");
            _ds.display(receiverPK,"receiverPK");
            _ds.display(compress,"compress");
            _ds.display(dup,"dup");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(pkgId, true);
            _ds.displaySimple(from, true);
            _ds.displaySimple(to, true);
            _ds.displaySimple(senderPK, true);
            _ds.displaySimple(receiverPK, true);
            _ds.displaySimple(compress, true);
            _ds.displaySimple(dup, false);
            return _os;
        }
    public:
        std::string pkgId;
        std::string from;
        std::string to;
        std::string senderPK;
        std::string receiverPK;
        taf::Char compress;
        taf::Char dup;
    };
    inline bool operator==(const Header&l, const Header&r)
    {
        return l.pkgId == r.pkgId && l.from == r.from && l.to == r.to && l.senderPK == r.senderPK && l.receiverPK == r.receiverPK && l.compress == r.compress && l.dup == r.dup;
    }
    inline bool operator!=(const Header&l, const Header&r)
    {
        return !(l == r);
    }

    struct Payload : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "Toon.Payload";
        }
        static string MD5()
        {
            return "e57f7f0f9ab4c367d155c2612ee8aefb";
        }
        Payload()
        :dataEncryptedType(0)
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(dataEncryptedType, 0);
            _os.write(encryptedKey, 1);
            _os.write(unencryptedData, 2);
            _os.write(data, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(dataEncryptedType, 0, true);
            _is.read(encryptedKey, 1, false);
            _is.read(unencryptedData, 2, false);
            _is.read(data, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(dataEncryptedType,"dataEncryptedType");
            _ds.display(encryptedKey,"encryptedKey");
            _ds.display(unencryptedData,"unencryptedData");
            _ds.display(data,"data");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(dataEncryptedType, true);
            _ds.displaySimple(encryptedKey, true);
            _ds.displaySimple(unencryptedData, true);
            _ds.displaySimple(data, false);
            return _os;
        }
    public:
        taf::Char dataEncryptedType;
        map<std::string, std::string> encryptedKey;
        vector<taf::Char> unencryptedData;
        vector<taf::Char> data;
    };
    inline bool operator==(const Payload&l, const Payload&r)
    {
        return l.dataEncryptedType == r.dataEncryptedType && l.encryptedKey == r.encryptedKey && l.unencryptedData == r.unencryptedData && l.data == r.data;
    }
    inline bool operator!=(const Payload&l, const Payload&r)
    {
        return !(l == r);
    }

    struct Datagram : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "Toon.Datagram";
        }
        static string MD5()
        {
            return "06d4f30c08a7ecd1377b3b7f65a7963e";
        }
        Datagram()
        :signatureType(0),signatureMethod(1),signature("")
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(signatureType, 0);
            _os.write(signatureMethod, 1);
            _os.write(signature, 2);
            _os.write(header, 3);
            _os.write(description, 4);
            _os.write(payload, 5);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(signatureType, 0, true);
            _is.read(signatureMethod, 1, false);
            _is.read(signature, 2, false);
            _is.read(header, 3, true);
            _is.read(description, 4, false);
            _is.read(payload, 5, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(signatureType,"signatureType");
            _ds.display(signatureMethod,"signatureMethod");
            _ds.display(signature,"signature");
            _ds.display(header,"header");
            _ds.display(description,"description");
            _ds.display(payload,"payload");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(signatureType, true);
            _ds.displaySimple(signatureMethod, true);
            _ds.displaySimple(signature, true);
            _ds.displaySimple(header, true);
            _ds.displaySimple(description, true);
            _ds.displaySimple(payload, false);
            return _os;
        }
    public:
        taf::Short signatureType;
        taf::Short signatureMethod;
        std::string signature;
        Toon::Header header;
        vector<taf::Char> description;
        Toon::Payload payload;
    };
    inline bool operator==(const Datagram&l, const Datagram&r)
    {
        return l.signatureType == r.signatureType && l.signatureMethod == r.signatureMethod && l.signature == r.signature && l.header == r.header && l.description == r.description && l.payload == r.payload;
    }
    inline bool operator!=(const Datagram&l, const Datagram&r)
    {
        return !(l == r);
    }

    struct MsgReq : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "Toon.MsgReq";
        }
        static string MD5()
        {
            return "695539da9e9ae4f2978b6f62cc161c1b";
        }
        MsgReq()
        :msg_id(""),seq_id(0),timestamp(0),type(0),from(""),to(""),session_id(""),flags(0),push_url("")
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(msg_id, 0);
            _os.write(seq_id, 1);
            _os.write(timestamp, 2);
            _os.write(type, 3);
            _os.write(from, 4);
            _os.write(to, 5);
            _os.write(session_id, 6);
            _os.write(content, 7);
            _os.write(flags, 8);
            _os.write(push_url, 9);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(msg_id, 0, true);
            _is.read(seq_id, 1, false);
            _is.read(timestamp, 2, false);
            _is.read(type, 3, true);
            _is.read(from, 4, true);
            _is.read(to, 5, true);
            _is.read(session_id, 6, true);
            _is.read(content, 7, false);
            _is.read(flags, 8, false);
            _is.read(push_url, 9, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(msg_id,"msg_id");
            _ds.display(seq_id,"seq_id");
            _ds.display(timestamp,"timestamp");
            _ds.display(type,"type");
            _ds.display(from,"from");
            _ds.display(to,"to");
            _ds.display(session_id,"session_id");
            _ds.display(content,"content");
            _ds.display(flags,"flags");
            _ds.display(push_url,"push_url");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(msg_id, true);
            _ds.displaySimple(seq_id, true);
            _ds.displaySimple(timestamp, true);
            _ds.displaySimple(type, true);
            _ds.displaySimple(from, true);
            _ds.displaySimple(to, true);
            _ds.displaySimple(session_id, true);
            _ds.displaySimple(content, true);
            _ds.displaySimple(flags, true);
            _ds.displaySimple(push_url, false);
            return _os;
        }
    public:
        std::string msg_id;
        taf::Int64 seq_id;
        taf::Int64 timestamp;
        taf::Int32 type;
        std::string from;
        std::string to;
        std::string session_id;
        vector<taf::Char> content;
        taf::Int32 flags;
        std::string push_url;
    };
    inline bool operator==(const MsgReq&l, const MsgReq&r)
    {
        return l.msg_id == r.msg_id && l.seq_id == r.seq_id && l.timestamp == r.timestamp && l.type == r.type && l.from == r.from && l.to == r.to && l.session_id == r.session_id && l.content == r.content && l.flags == r.flags && l.push_url == r.push_url;
    }
    inline bool operator!=(const MsgReq&l, const MsgReq&r)
    {
        return !(l == r);
    }

    struct MsgDescription : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "Toon.MsgDescription";
        }
        static string MD5()
        {
            return "a0f7f1c70b82271b1f084e61faf77494";
        }
        MsgDescription()
        :seq_id(0),timestamp(0)
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(seq_id, 0);
            _os.write(timestamp, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(seq_id, 0, false);
            _is.read(timestamp, 1, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(seq_id,"seq_id");
            _ds.display(timestamp,"timestamp");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(seq_id, true);
            _ds.displaySimple(timestamp, false);
            return _os;
        }
    public:
        taf::Int64 seq_id;
        taf::Int64 timestamp;
    };
    inline bool operator==(const MsgDescription&l, const MsgDescription&r)
    {
        return l.seq_id == r.seq_id && l.timestamp == r.timestamp;
    }
    inline bool operator!=(const MsgDescription&l, const MsgDescription&r)
    {
        return !(l == r);
    }

    struct MsgUnencryptedData : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "Toon.MsgUnencryptedData";
        }
        static string MD5()
        {
            return "092a477e21324653406a8e3749503cbb";
        }
        MsgUnencryptedData()
        :type(0),session_id(""),flags(0)
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(type, 0);
            _os.write(session_id, 1);
            _os.write(flags, 2);
            _os.write(data, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(type, 0, true);
            _is.read(session_id, 1, true);
            _is.read(flags, 2, false);
            _is.read(data, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(type,"type");
            _ds.display(session_id,"session_id");
            _ds.display(flags,"flags");
            _ds.display(data,"data");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(type, true);
            _ds.displaySimple(session_id, true);
            _ds.displaySimple(flags, true);
            _ds.displaySimple(data, false);
            return _os;
        }
    public:
        taf::Int32 type;
        std::string session_id;
        taf::Int32 flags;
        vector<taf::Char> data;
    };
    inline bool operator==(const MsgUnencryptedData&l, const MsgUnencryptedData&r)
    {
        return l.type == r.type && l.session_id == r.session_id && l.flags == r.flags && l.data == r.data;
    }
    inline bool operator!=(const MsgUnencryptedData&l, const MsgUnencryptedData&r)
    {
        return !(l == r);
    }

    struct GroupReq : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "Toon.GroupReq";
        }
        static string MD5()
        {
            return "c9297db2d658badddcde8e004c809945";
        }
        GroupReq()
        :msg_id(""),group_id("")
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(msg_id, 0);
            _os.write(group_id, 1);
            _os.write(tcids, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(msg_id, 0, true);
            _is.read(group_id, 1, true);
            _is.read(tcids, 2, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(msg_id,"msg_id");
            _ds.display(group_id,"group_id");
            _ds.display(tcids,"tcids");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(msg_id, true);
            _ds.displaySimple(group_id, true);
            _ds.displaySimple(tcids, false);
            return _os;
        }
    public:
        std::string msg_id;
        std::string group_id;
        vector<std::string> tcids;
    };
    inline bool operator==(const GroupReq&l, const GroupReq&r)
    {
        return l.msg_id == r.msg_id && l.group_id == r.group_id && l.tcids == r.tcids;
    }
    inline bool operator!=(const GroupReq&l, const GroupReq&r)
    {
        return !(l == r);
    }

    struct RandomResp : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "Toon.RandomResp";
        }
        static string MD5()
        {
            return "05511bece4a2b65e1361cf6867461c97";
        }
        RandomResp()
        :random(0)
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(random, 0);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(random, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(random,"random");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(random, false);
            return _os;
        }
    public:
        taf::Int32 random;
    };
    inline bool operator==(const RandomResp&l, const RandomResp&r)
    {
        return l.random == r.random;
    }
    inline bool operator!=(const RandomResp&l, const RandomResp&r)
    {
        return !(l == r);
    }

    struct ConnectReq : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "Toon.ConnectReq";
        }
        static string MD5()
        {
            return "d41cd31e675b0ac5d426f93d23b830f3";
        }
        ConnectReq()
        :tuid(""),secret_text(""),device_id(""),device_type(0),push_token(""),push_service_type(0),app_type(100),toon_type(100),protocol_version(0),app_version("")
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(tuid, 0);
            _os.write(secret_text, 1);
            _os.write(device_id, 2);
            _os.write(device_type, 3);
            _os.write(push_token, 4);
            _os.write(push_service_type, 5);
            _os.write(app_type, 6);
            _os.write(toon_type, 7);
            _os.write(protocol_version, 8);
            _os.write(app_version, 9);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(tuid, 0, true);
            _is.read(secret_text, 1, true);
            _is.read(device_id, 2, false);
            _is.read(device_type, 3, false);
            _is.read(push_token, 4, false);
            _is.read(push_service_type, 5, false);
            _is.read(app_type, 6, false);
            _is.read(toon_type, 7, false);
            _is.read(protocol_version, 8, false);
            _is.read(app_version, 9, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(tuid,"tuid");
            _ds.display(secret_text,"secret_text");
            _ds.display(device_id,"device_id");
            _ds.display(device_type,"device_type");
            _ds.display(push_token,"push_token");
            _ds.display(push_service_type,"push_service_type");
            _ds.display(app_type,"app_type");
            _ds.display(toon_type,"toon_type");
            _ds.display(protocol_version,"protocol_version");
            _ds.display(app_version,"app_version");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(tuid, true);
            _ds.displaySimple(secret_text, true);
            _ds.displaySimple(device_id, true);
            _ds.displaySimple(device_type, true);
            _ds.displaySimple(push_token, true);
            _ds.displaySimple(push_service_type, true);
            _ds.displaySimple(app_type, true);
            _ds.displaySimple(toon_type, true);
            _ds.displaySimple(protocol_version, true);
            _ds.displaySimple(app_version, false);
            return _os;
        }
    public:
        std::string tuid;
        std::string secret_text;
        std::string device_id;
        taf::Int32 device_type;
        std::string push_token;
        taf::Int32 push_service_type;
        taf::Int32 app_type;
        taf::Int32 toon_type;
        taf::Int32 protocol_version;
        std::string app_version;
    };
    inline bool operator==(const ConnectReq&l, const ConnectReq&r)
    {
        return l.tuid == r.tuid && l.secret_text == r.secret_text && l.device_id == r.device_id && l.device_type == r.device_type && l.push_token == r.push_token && l.push_service_type == r.push_service_type && l.app_type == r.app_type && l.toon_type == r.toon_type && l.protocol_version == r.protocol_version && l.app_version == r.app_version;
    }
    inline bool operator!=(const ConnectReq&l, const ConnectReq&r)
    {
        return !(l == r);
    }

    struct ConnectResp : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "Toon.ConnectResp";
        }
        static string MD5()
        {
            return "b863b0648026ff242f15c7a7600dbbe9";
        }
        ConnectResp()
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write((taf::Int32)code, 0);
            _os.write(forbidden_content_type, 1);
            _os.write(toon_type_switch, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read((taf::Int32&)code, 0, true);
            _is.read(forbidden_content_type, 1, false);
            _is.read(toon_type_switch, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display((taf::Int32)code,"code");
            _ds.display(forbidden_content_type,"forbidden_content_type");
            _ds.display(toon_type_switch,"toon_type_switch");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple((taf::Int32)code, true);
            _ds.displaySimple(forbidden_content_type, true);
            _ds.displaySimple(toon_type_switch, false);
            return _os;
        }
    public:
        Toon_CONNECT_RESULT code;
        vector<taf::Int32> forbidden_content_type;
        map<std::string, taf::Int32> toon_type_switch;
    };
    inline bool operator==(const ConnectResp&l, const ConnectResp&r)
    {
        return l.code == r.code && l.forbidden_content_type == r.forbidden_content_type && l.toon_type_switch == r.toon_type_switch;
    }
    inline bool operator!=(const ConnectResp&l, const ConnectResp&r)
    {
        return !(l == r);
    }

    struct KickOutReq : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "Toon.KickOutReq";
        }
        static string MD5()
        {
            return "feec12de7b13d3c49a37abb722ac4db4";
        }
        KickOutReq()
        :toon_type(-1),device_type(-1)
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(toon_type, 0);
            _os.write(device_type, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(toon_type, 0, true);
            _is.read(device_type, 1, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(toon_type,"toon_type");
            _ds.display(device_type,"device_type");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(toon_type, true);
            _ds.displaySimple(device_type, false);
            return _os;
        }
    public:
        taf::Int32 toon_type;
        taf::Int32 device_type;
    };
    inline bool operator==(const KickOutReq&l, const KickOutReq&r)
    {
        return l.toon_type == r.toon_type && l.device_type == r.device_type;
    }
    inline bool operator!=(const KickOutReq&l, const KickOutReq&r)
    {
        return !(l == r);
    }

    struct KickOutAck : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "Toon.KickOutAck";
        }
        static string MD5()
        {
            return "05511bece4a2b65e1361cf6867461c97";
        }
        KickOutAck()
        :code(0)
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(code, 0);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(code, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(code,"code");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(code, false);
            return _os;
        }
    public:
        taf::Int32 code;
    };
    inline bool operator==(const KickOutAck&l, const KickOutAck&r)
    {
        return l.code == r.code;
    }
    inline bool operator!=(const KickOutAck&l, const KickOutAck&r)
    {
        return !(l == r);
    }

    struct GroupResp : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "Toon.GroupResp";
        }
        static string MD5()
        {
            return "ecf5eae4ff24e7e8f68c5876b0e3cd34";
        }
        GroupResp()
        :msg_id("")
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(msg_id, 0);
            _os.write((taf::Int32)code, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(msg_id, 0, true);
            _is.read((taf::Int32&)code, 1, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(msg_id,"msg_id");
            _ds.display((taf::Int32)code,"code");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(msg_id, true);
            _ds.displaySimple((taf::Int32)code, false);
            return _os;
        }
    public:
        std::string msg_id;
        Toon_GROUP_RESULT code;
    };
    inline bool operator==(const GroupResp&l, const GroupResp&r)
    {
        return l.msg_id == r.msg_id && l.code == r.code;
    }
    inline bool operator!=(const GroupResp&l, const GroupResp&r)
    {
        return !(l == r);
    }

    struct MsgAck : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "Toon.MsgAck";
        }
        static string MD5()
        {
            return "c91b2ea212a3f0c5a15357d8ecda2b30";
        }
        MsgAck()
        :retcode(0),msg_id(""),seq_id(0),session_id(""),timestamp(0)
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(retcode, 0);
            _os.write(msg_id, 1);
            _os.write(seq_id, 2);
            _os.write(session_id, 3);
            _os.write(timestamp, 4);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(retcode, 0, false);
            _is.read(msg_id, 1, false);
            _is.read(seq_id, 2, false);
            _is.read(session_id, 3, true);
            _is.read(timestamp, 4, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(retcode,"retcode");
            _ds.display(msg_id,"msg_id");
            _ds.display(seq_id,"seq_id");
            _ds.display(session_id,"session_id");
            _ds.display(timestamp,"timestamp");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(retcode, true);
            _ds.displaySimple(msg_id, true);
            _ds.displaySimple(seq_id, true);
            _ds.displaySimple(session_id, true);
            _ds.displaySimple(timestamp, false);
            return _os;
        }
    public:
        taf::Int32 retcode;
        std::string msg_id;
        taf::Int64 seq_id;
        std::string session_id;
        taf::Int64 timestamp;
    };
    inline bool operator==(const MsgAck&l, const MsgAck&r)
    {
        return l.retcode == r.retcode && l.msg_id == r.msg_id && l.seq_id == r.seq_id && l.session_id == r.session_id && l.timestamp == r.timestamp;
    }
    inline bool operator!=(const MsgAck&l, const MsgAck&r)
    {
        return !(l == r);
    }

    struct HotSessionReq : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "Toon.HotSessionReq";
        }
        static string MD5()
        {
            return "c5d29a3a3b5e33926ecd936ff3153e6b";
        }
        HotSessionReq()
        :timestamp(0)
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(timestamp, 0);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(timestamp, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(timestamp,"timestamp");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(timestamp, false);
            return _os;
        }
    public:
        taf::Int64 timestamp;
    };
    inline bool operator==(const HotSessionReq&l, const HotSessionReq&r)
    {
        return l.timestamp == r.timestamp;
    }
    inline bool operator!=(const HotSessionReq&l, const HotSessionReq&r)
    {
        return !(l == r);
    }

    struct HotSessionItem : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "Toon.HotSessionItem";
        }
        static string MD5()
        {
            return "ab704286580576fe21e68bb3f7cf456a";
        }
        HotSessionItem()
        :read_seq_id(0),unread_num(-1)
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(read_seq_id, 0);
            _os.write(unread_num, 1);
            _os.write(msgs, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(read_seq_id, 0, true);
            _is.read(unread_num, 1, false);
            _is.read(msgs, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(read_seq_id,"read_seq_id");
            _ds.display(unread_num,"unread_num");
            _ds.display(msgs,"msgs");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(read_seq_id, true);
            _ds.displaySimple(unread_num, true);
            _ds.displaySimple(msgs, false);
            return _os;
        }
    public:
        taf::Int64 read_seq_id;
        taf::Int32 unread_num;
        vector<Toon::Datagram> msgs;
    };
    inline bool operator==(const HotSessionItem&l, const HotSessionItem&r)
    {
        return l.read_seq_id == r.read_seq_id && l.unread_num == r.unread_num && l.msgs == r.msgs;
    }
    inline bool operator!=(const HotSessionItem&l, const HotSessionItem&r)
    {
        return !(l == r);
    }

    struct HotSessionResp : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "Toon.HotSessionResp";
        }
        static string MD5()
        {
            return "5d3c13079cae78328e2186c87b9a718f";
        }
        HotSessionResp()
        :code(0),timestamp(0)
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(code, 0);
            _os.write(timestamp, 1);
            _os.write(vSessionInfo, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(code, 0, true);
            _is.read(timestamp, 1, true);
            _is.read(vSessionInfo, 2, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(code,"code");
            _ds.display(timestamp,"timestamp");
            _ds.display(vSessionInfo,"vSessionInfo");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(code, true);
            _ds.displaySimple(timestamp, true);
            _ds.displaySimple(vSessionInfo, false);
            return _os;
        }
    public:
        taf::Int32 code;
        taf::Int64 timestamp;
        vector<Toon::HotSessionItem> vSessionInfo;
    };
    inline bool operator==(const HotSessionResp&l, const HotSessionResp&r)
    {
        return l.code == r.code && l.timestamp == r.timestamp && l.vSessionInfo == r.vSessionInfo;
    }
    inline bool operator!=(const HotSessionResp&l, const HotSessionResp&r)
    {
        return !(l == r);
    }

    struct PullOffMsgReq : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "Toon.PullOffMsgReq";
        }
        static string MD5()
        {
            return "8e8f3812cec30eb5b2eebae667d563e9";
        }
        PullOffMsgReq()
        :max_seq_id(0),min_seq_id(0),limit_count(0),session_id("")
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(max_seq_id, 0);
            _os.write(min_seq_id, 1);
            _os.write(limit_count, 2);
            _os.write(session_id, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(max_seq_id, 0, true);
            _is.read(min_seq_id, 1, true);
            _is.read(limit_count, 2, true);
            _is.read(session_id, 3, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(max_seq_id,"max_seq_id");
            _ds.display(min_seq_id,"min_seq_id");
            _ds.display(limit_count,"limit_count");
            _ds.display(session_id,"session_id");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(max_seq_id, true);
            _ds.displaySimple(min_seq_id, true);
            _ds.displaySimple(limit_count, true);
            _ds.displaySimple(session_id, false);
            return _os;
        }
    public:
        taf::Int64 max_seq_id;
        taf::Int64 min_seq_id;
        taf::Int32 limit_count;
        std::string session_id;
    };
    inline bool operator==(const PullOffMsgReq&l, const PullOffMsgReq&r)
    {
        return l.max_seq_id == r.max_seq_id && l.min_seq_id == r.min_seq_id && l.limit_count == r.limit_count && l.session_id == r.session_id;
    }
    inline bool operator!=(const PullOffMsgReq&l, const PullOffMsgReq&r)
    {
        return !(l == r);
    }

    struct PullOffMsgResp : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "Toon.PullOffMsgResp";
        }
        static string MD5()
        {
            return "4579d392d019d8d5c76ea9af2c2458c8";
        }
        PullOffMsgResp()
        :code(0)
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(code, 0);
            _os.write(msgs, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(code, 0, false);
            _is.read(msgs, 1, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(code,"code");
            _ds.display(msgs,"msgs");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(code, true);
            _ds.displaySimple(msgs, false);
            return _os;
        }
    public:
        taf::Int32 code;
        vector<Toon::Datagram> msgs;
    };
    inline bool operator==(const PullOffMsgResp&l, const PullOffMsgResp&r)
    {
        return l.code == r.code && l.msgs == r.msgs;
    }
    inline bool operator!=(const PullOffMsgResp&l, const PullOffMsgResp&r)
    {
        return !(l == r);
    }

    struct HighMessageReq : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "Toon.HighMessageReq";
        }
        static string MD5()
        {
            return "c5d29a3a3b5e33926ecd936ff3153e6b";
        }
        HighMessageReq()
        :seqId(0)
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(seqId, 0);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(seqId, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(seqId,"seqId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(seqId, false);
            return _os;
        }
    public:
        taf::Int64 seqId;
    };
    inline bool operator==(const HighMessageReq&l, const HighMessageReq&r)
    {
        return l.seqId == r.seqId;
    }
    inline bool operator!=(const HighMessageReq&l, const HighMessageReq&r)
    {
        return !(l == r);
    }

    struct ClientReport : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "Toon.ClientReport";
        }
        static string MD5()
        {
            return "26159cf77dcb9fe1c64b57dae580ccae";
        }
        ClientReport()
        :type(0),content("")
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(type, 0);
            _os.write(content, 1);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(type, 0, true);
            _is.read(content, 1, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(type,"type");
            _ds.display(content,"content");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(type, true);
            _ds.displaySimple(content, false);
            return _os;
        }
    public:
        taf::Int32 type;
        std::string content;
    };
    inline bool operator==(const ClientReport&l, const ClientReport&r)
    {
        return l.type == r.type && l.content == r.content;
    }
    inline bool operator!=(const ClientReport&l, const ClientReport&r)
    {
        return !(l == r);
    }

    struct SyncReq : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "Toon.SyncReq";
        }
        static string MD5()
        {
            return "8d61b639cda77ea57102c6b9cbb5aca2";
        }
        SyncReq()
        :tuid(""),push_token("-1"),apns_unreadnum(-1)
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(tuid, 0);
            _os.write(push_token, 1);
            _os.write(apns_unreadnum, 2);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(tuid, 0, true);
            _is.read(push_token, 1, false);
            _is.read(apns_unreadnum, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(tuid,"tuid");
            _ds.display(push_token,"push_token");
            _ds.display(apns_unreadnum,"apns_unreadnum");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(tuid, true);
            _ds.displaySimple(push_token, true);
            _ds.displaySimple(apns_unreadnum, false);
            return _os;
        }
    public:
        std::string tuid;
        std::string push_token;
        taf::Int32 apns_unreadnum;
    };
    inline bool operator==(const SyncReq&l, const SyncReq&r)
    {
        return l.tuid == r.tuid && l.push_token == r.push_token && l.apns_unreadnum == r.apns_unreadnum;
    }
    inline bool operator!=(const SyncReq&l, const SyncReq&r)
    {
        return !(l == r);
    }

    struct SyncResp : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "Toon.SyncResp";
        }
        static string MD5()
        {
            return "05511bece4a2b65e1361cf6867461c97";
        }
        SyncResp()
        :code(0)
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(code, 0);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(code, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(code,"code");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(code, false);
            return _os;
        }
    public:
        taf::Int32 code;
    };
    inline bool operator==(const SyncResp&l, const SyncResp&r)
    {
        return l.code == r.code;
    }
    inline bool operator!=(const SyncResp&l, const SyncResp&r)
    {
        return !(l == r);
    }

    struct SyncSessionStatusReq : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "Toon.SyncSessionStatusReq";
        }
        static string MD5()
        {
            return "290397433ced0a474ba460c7fe60b1c4";
        }
        SyncSessionStatusReq()
        :tcid(""),session_id(""),read_seq_id(0),apns_unreadnum(-1)
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(tcid, 0);
            _os.write(session_id, 1);
            _os.write(read_seq_id, 2);
            _os.write(apns_unreadnum, 3);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(tcid, 0, true);
            _is.read(session_id, 1, true);
            _is.read(read_seq_id, 2, true);
            _is.read(apns_unreadnum, 3, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(tcid,"tcid");
            _ds.display(session_id,"session_id");
            _ds.display(read_seq_id,"read_seq_id");
            _ds.display(apns_unreadnum,"apns_unreadnum");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(tcid, true);
            _ds.displaySimple(session_id, true);
            _ds.displaySimple(read_seq_id, true);
            _ds.displaySimple(apns_unreadnum, false);
            return _os;
        }
    public:
        std::string tcid;
        std::string session_id;
        taf::Int64 read_seq_id;
        taf::Int32 apns_unreadnum;
    };
    inline bool operator==(const SyncSessionStatusReq&l, const SyncSessionStatusReq&r)
    {
        return l.tcid == r.tcid && l.session_id == r.session_id && l.read_seq_id == r.read_seq_id && l.apns_unreadnum == r.apns_unreadnum;
    }
    inline bool operator!=(const SyncSessionStatusReq&l, const SyncSessionStatusReq&r)
    {
        return !(l == r);
    }

    struct SyncSessionStatusResp : public taf::JceStructBase
    {
    public:
        static string className()
        {
            return "Toon.SyncSessionStatusResp";
        }
        static string MD5()
        {
            return "05511bece4a2b65e1361cf6867461c97";
        }
        SyncSessionStatusResp()
        :code(0)
        {
        }
        template<typename WriterT>
        void writeTo(taf::JceOutputStream<WriterT>& _os) const
        {
            _os.write(code, 0);
        }
        template<typename ReaderT>
        void readFrom(taf::JceInputStream<ReaderT>& _is)
        {
            _is.read(code, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.display(code,"code");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            taf::JceDisplayer _ds(_os, _level);
            _ds.displaySimple(code, false);
            return _os;
        }
    public:
        taf::Int32 code;
    };
    inline bool operator==(const SyncSessionStatusResp&l, const SyncSessionStatusResp&r)
    {
        return l.code == r.code;
    }
    inline bool operator!=(const SyncSessionStatusResp&l, const SyncSessionStatusResp&r)
    {
        return !(l == r);
    }


}

#define Toon_Header_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.pkgId,b.pkgId);jce_copy_struct(a.from,b.from);jce_copy_struct(a.to,b.to);jce_copy_struct(a.senderPK,b.senderPK);jce_copy_struct(a.receiverPK,b.receiverPK);jce_copy_struct(a.compress,b.compress);jce_copy_struct(a.dup,b.dup);

#define Toon_Payload_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.dataEncryptedType,b.dataEncryptedType);jce_copy_struct(a.encryptedKey,b.encryptedKey);jce_copy_struct(a.unencryptedData,b.unencryptedData);jce_copy_struct(a.data,b.data);

#define Toon_Datagram_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.signatureType,b.signatureType);jce_copy_struct(a.signatureMethod,b.signatureMethod);jce_copy_struct(a.signature,b.signature);jce_copy_struct(a.header,b.header);jce_copy_struct(a.description,b.description);jce_copy_struct(a.payload,b.payload);

#define Toon_MsgReq_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.msg_id,b.msg_id);jce_copy_struct(a.seq_id,b.seq_id);jce_copy_struct(a.timestamp,b.timestamp);jce_copy_struct(a.type,b.type);jce_copy_struct(a.from,b.from);jce_copy_struct(a.to,b.to);jce_copy_struct(a.session_id,b.session_id);jce_copy_struct(a.content,b.content);jce_copy_struct(a.flags,b.flags);jce_copy_struct(a.push_url,b.push_url);

#define Toon_MsgDescription_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.seq_id,b.seq_id);jce_copy_struct(a.timestamp,b.timestamp);

#define Toon_MsgUnencryptedData_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.type,b.type);jce_copy_struct(a.session_id,b.session_id);jce_copy_struct(a.flags,b.flags);jce_copy_struct(a.data,b.data);

#define Toon_GroupReq_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.msg_id,b.msg_id);jce_copy_struct(a.group_id,b.group_id);jce_copy_struct(a.tcids,b.tcids);

#define Toon_RandomResp_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.random,b.random);

#define Toon_ConnectReq_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.tuid,b.tuid);jce_copy_struct(a.secret_text,b.secret_text);jce_copy_struct(a.device_id,b.device_id);jce_copy_struct(a.device_type,b.device_type);jce_copy_struct(a.push_token,b.push_token);jce_copy_struct(a.push_service_type,b.push_service_type);jce_copy_struct(a.app_type,b.app_type);jce_copy_struct(a.toon_type,b.toon_type);jce_copy_struct(a.protocol_version,b.protocol_version);jce_copy_struct(a.app_version,b.app_version);

#define Toon_ConnectResp_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.code,b.code);jce_copy_struct(a.forbidden_content_type,b.forbidden_content_type);jce_copy_struct(a.toon_type_switch,b.toon_type_switch);

#define Toon_KickOutReq_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.toon_type,b.toon_type);jce_copy_struct(a.device_type,b.device_type);

#define Toon_KickOutAck_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.code,b.code);

#define Toon_GroupResp_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.msg_id,b.msg_id);jce_copy_struct(a.code,b.code);

#define Toon_MsgAck_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.retcode,b.retcode);jce_copy_struct(a.msg_id,b.msg_id);jce_copy_struct(a.seq_id,b.seq_id);jce_copy_struct(a.session_id,b.session_id);jce_copy_struct(a.timestamp,b.timestamp);

#define Toon_HotSessionReq_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.timestamp,b.timestamp);

#define Toon_HotSessionItem_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.read_seq_id,b.read_seq_id);jce_copy_struct(a.unread_num,b.unread_num);jce_copy_struct(a.msgs,b.msgs);

#define Toon_HotSessionResp_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.code,b.code);jce_copy_struct(a.timestamp,b.timestamp);jce_copy_struct(a.vSessionInfo,b.vSessionInfo);

#define Toon_PullOffMsgReq_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.max_seq_id,b.max_seq_id);jce_copy_struct(a.min_seq_id,b.min_seq_id);jce_copy_struct(a.limit_count,b.limit_count);jce_copy_struct(a.session_id,b.session_id);

#define Toon_PullOffMsgResp_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.code,b.code);jce_copy_struct(a.msgs,b.msgs);

#define Toon_HighMessageReq_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.seqId,b.seqId);

#define Toon_ClientReport_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.type,b.type);jce_copy_struct(a.content,b.content);

#define Toon_SyncReq_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.tuid,b.tuid);jce_copy_struct(a.push_token,b.push_token);jce_copy_struct(a.apns_unreadnum,b.apns_unreadnum);

#define Toon_SyncResp_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.code,b.code);

#define Toon_SyncSessionStatusReq_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.tcid,b.tcid);jce_copy_struct(a.session_id,b.session_id);jce_copy_struct(a.read_seq_id,b.read_seq_id);jce_copy_struct(a.apns_unreadnum,b.apns_unreadnum);

#define Toon_SyncSessionStatusResp_JCE_COPY_STRUCT_HELPER   \
        jce_copy_struct(a.code,b.code);



#endif
